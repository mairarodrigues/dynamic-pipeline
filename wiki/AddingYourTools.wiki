#summary Instructions for instantiating the dynamic pipeline system with your tools.

= Introduction =

To use the dynamic pipeline system you must add your own tools to the system. These tools are the ones to be considered for pipeline generation. It is recommended that your tools are, in some degree, compatible in terms of inputs and outputs, so that their combination in a pipeline is possible.

To add your tools to the dynamic pipeline system you will need to:
 # populate the folder "tools/" with the tools you want to include in your pipeline system; and
 # instantiate the Tool Registry (`registry/ToolRegistry.txt`) with information about those tools. 

= The Tool Registry =

All information about the tools that are part of the pipeline system is stored in a data structure called Tool Registry (the `registry/ToolRegistry.txt` file). Each entry on the registry describes a particular tool with the following attributes:
 * the input that it accepts (Input), which can be a file type or format; 
 * the output that it generates (Output), that can also be a file type or format; 
 * its executable name (Tool); 
 * its programming language (Language); 
 * an identification number (Code); 
 * a list of extra input files required to run it (XI or input dependencies), separated by commas; 
 * a list of secondary output files generated by the tool (XO or subproducts), separated by commas; 
 * a performance measure, indicating its average execution time (Performance); 
 * free text observations that the tool provider thinks the user must know in order to run it (Observations);  
 * the provider's name (Provider); and
 * the provider's contact (Contact).

Example:
||#INPUT||OUTPUT ||TOOL||LANGUAGE||CODE||DEPENDENCIES||SUBPRODUCTS||PERFORMANCE||OBSERVATIONS||PROVIDER||CONTACT||
||!FileType1||!FileType2 ||toolX.pl||Perl||01||!FileType3||-||0.25||-||John Smith||john@mail||
||!FileType5||!FileType6 ||toolY.pl||Perl||02||-||!FileType9||0.92||-||Paul||paul@mail||
||!FileType2||!FileType5 ||toolZ.pl||Perl||03||!FileType9,!FileType8||-||3.20||-||Paul||paul@mail||


The first entry describes a tool `toolX.pl` written in `Perl` that performs some processing on `FileType1` and generates `FileType2`, and requires an extra input file `FileType3`. Its performance measure is `0.25` (see the Section Performance Measure on how to determine it). The second entry describes a tool `toolY.pl` written in `Perl` that performs some processing on `FileType5` and generates `FileType6` and a second output file `FileType9`. The third entry describes a tool `toolZ.pl` that performs some processing on `FileType2` and generates file `FileType5` using two extra input files, `FileType9` and `FileType8`.

==Performance Measure==

The performance measure indicates the time that the tool takes to finish its execution. It is used to identify the fastest pipeline, in case there are alternative pipelines for the same task. It is calculated as follows:

{{{performance_measure = (time/filesizesum)*10}}}

where `time` is the time the tool took to execute (in seconds), and `filesizesum` is the size of its input file (in KB) (or files, in
case the tool requires extra input files). You can use the program ` CalculatePerformance` to calculate the performance measure (see the Wiki page User_Manual on how to run this program).

To determine the `time` value for your tools, we suggest that you use the Unix "time" command together with your tools' command line. 

*Note:* you should use the same machine to determine the `time` value for the tools in your system, since the time that tools take to process will depend on the machine's configuration. Therefore, different configurations will result in a biased performance measure.

=Standards for each Tool=

Each tool in the pipeline (folder "`/tools`") is invoked by a command line call with the following format: 
{{{
<programing language call> <tool executable name> <input file 1> [input file n] <output file 1> [output file n]
}}}
where squared brackets represent optional parameters; that is, in case a tool requires extra inputs (represented by the Dependencies attribute in the tool registry) or generates secondary output files (represented by the Subproducts attribute in the tool registry).

In the examples above, the algorithm generates a command line call for each tool in the format:
{{{
perl toolX.pl File1 File3 File2

perl toolY.pl File5 File6 File9

perl toolZ.pl File2 File9 File8 File5
}}}
The tool developer is the one responsible for setting the correct command line interface for his tool and for describing it correctly in the tool registry. If the tool interface is not correctly described, the algorithm will not be able to invoke the tool. 